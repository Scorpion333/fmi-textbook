# Особени случаи във void функции

Нерядко се случва да имаме функция, за която е вярно, че:

- няма очевидна причина да връща стойност
- има 1-2 случая, в които функцията няма смислено поведение - дори и да я оставим да не направи нищо, това може да е проблем

Пример: Искаме да напишем метод на DynamicArray, който добавя елемент X след друг елемент Y.

Ако в масива има Y, това не е проблем:
    
    template<typename T>
    class DynamicArray {
        // ...
        
        void add_after(T x, T y) {
            unsigned i = 0;
            while(arr[i] != y) {
                i++;
            }
            // Ако има Y, той е на позиция i.
            insert_at_index(x, i + 1);
        }
        void insert_at_index(T x, unsigned index) {
            // Да предположим, че сме написали добре този помощен метод. :)
        }
    };
    
А ако няма Y? Това може да се провери, но въпросът е какво да се прави. Идеи много - да не става нищо, Х да се добави в края,
Х да се добави на случайна позиция, да добавим първо едно Y и след него X, компилаторът да даде грешка...
Какво е най-добре да се направи, зависи от конкретната ситуация и от спецификацията/условието на по-големия проблем, който се решава.

Тъй като няма единствено логично действие, а клас като DynamicArray би трябвало да е максимално универсален*, разумна идея би била в
особения случай да не се случва нищо с масива, но да се даде информация, че методът не се е изпълнил успешно.

(*Клас "динамичен масив" наистина е много практична идея. Почти винаги, когато има нужда от структура от еднотипни данни в С++,
се изполва vector - вградения в стандартната библиотека еквивалент на DynamicArray.)

## Как bool може да помогне?

Идеята е проста - функцията става булева и връща стойност true, ако всичко е било наред, и false, ако сме попаднали в особения случай
(corner case) и не се е изпълнила успешно:

    bool add_after(T x, T y) {
        unsigned i = 0;
        while(i < size && arr[i] != y) {
            i++;
        }
        if(i < size) {
            insert_at_index(x, i + 1);
            return true;
        }
        else {
            // Стигнали сме до края и няма Y.
            return false;
        }
    }

Сега, когато искаме да използваме този метод и има вероятност да сме в особения случай, можем да направим това:

    DynamicArray d;
    // ...
    if(d.add_after(x, y)) {
        // Ок, Х е добавено, може да продължим по правия път.
    }
    else {
        // В масива няма Y, значи правим нещо друго.
    }
    
## По-сложни ситуации

Bool вместо void е добра идея, но какво става, ако нашата функция не е void и трябва да върне друга стойност.
(Примери - оператор [ ], метод, който връща пръвия индекс, за който е изпълнено дадено условие...)
Обикновено е най-добре да има специална стойност за грешка (празна стойност). За всеки тип данни тази стойност би била различна:

- Ако функцията връща указател, е най-лесно - NULL.
- Ако трябва да се върне символ - '\0' най-често върши работа.
- Ако в общия случай трябва да се върне положително число, в особения може да се връща -1.
- Ако се връща число и знаем, че то в общия случай ще е по-малко 1 000 000, може да използваме 1 000 000 за "безкрайност".
- Понякога, ако трябва да се върне обект от клас, конструкторът по подразбиране създава подходящ за "празен" обект.

Не винаги съществува подходяща стойност за грешка, но когато я има, вероятно тази идея ще е по-добра от, например, assert или
хвърляне на exception.