# Итератори

## Дефиниция

Итераторът е клас, имитиращ указател. Указател към елемент на структура от данни.
Ако една структура има n елемента, нейният итератор трябва да може да бъде "насочван" към n+1 неща:

- всичките n валидни елемента на структурата
- стойност за грешка (По-долу ще я бележа с END.)

END трябва да е нещо **извън структурата** (напр. nullptr или невалидна позиция в масив, зависи от структурата).
Подвеждащото име идва от това, че обикновено натам "насочваме" итератора, след като той е минал през всички елементи.
Тоест, стигнем ли до END, значи сме стигнали края.

Можем условно да дефинираме "сочене" и "преместване" така:

- итератор it "сочи" X, ако като напишеш *it, това е Х
- "преместваме" итератор it, ако го "насочим" към нещо друго

## Употреба

Използва се за лесно обхождане на структурата. За целта структурата трябва да има два метода, връщащи итератор

- begin() - итератор към първия елемент, който искаме да посетим (ако структурата е празна - END)
- end() - итератор към END

И така, ако искаме да обходим всички елементи, насочваме итератор към begin() и го "местим", докато не почне да сочи end().

Пример:

    List<int> lis = { 2, 0, 1, 8 };

    for(List<int>::Iterator it = lis.begin();  it != lis.end();  ++it) {
        cout << *it;
    }
    // На екрана: 2018

## Ама кодът е грозен!

Няма пълно щастие.

## Как се пише

Тъй като итераторът е винаги свързан с конкретна структура от данни, е удобно той да се напише като вложен клас.

    template<typename T>
    class MyStructure {
        ...
    public:
        class Iterator {
            ...
        public:
            Iterator( ... )           { ... }     // Конструктор - за да може да създадем итератор в begin() и end().

            T    operator* () const   { ... }     // Както и в други случаи, за достъп до елемент е удобно да имаме
            T&   operator* ()         { ... }     // два варианта на метода. Повече за това - по-надолу.
            bool operator != () const { ... }
            void operator ++ ()       { ... }     // Или T& operator++(), ако много държим на добрите практики
        }

        Iterator begin() const {
            return Iterator( ... );
        }
        Iterator end() const {
            return Iterator( ... );
        }
    }

За да се използва итераторът като указател, той трябва да има три публични метода-оператори:

<table>
  <tr>
    <td>*</td>
    <td>за достъп до стойността на елемента, към който "сочи" итераторът</td>
  </tr>

  <tr>
    <td>!=</td>
    <td>за сравнение (рядко проверяваме нещо друго освен it != end)</td>
  </tr>

  <tr>
    <td>++</td>
    <td>за "насочване" към следващия елемент (или end(), ако няма следващ)</td>
  </tr>
</table>

## Какви да са член-данните на итератора и стойността за end()

Член-данните, необходими на итератора са тези, които му трябват за * и ++ (в != просто сравняваме тези данни).
Т.е. трябва да се сетим какви данни да пазим, че хем да достъпваме елемента, хем да да можем да стигнем и до другите елементи.

Обикновено е очевидно какво ще е begin().
Необходимо е обаче изберем "стойност" (т.е. състояние на член-данните на итератора) за end().
Най-добре е, ако до end() се стига "по естествен път".

Изберем ли член-данните и end(), не е трудно да напишем операторите.

Ето идеи за някои структури:

<table>
  <tr>
    <td>Структура</td>
    <td>Член-данни на итератора</td>
    <td>Как стигаме до другите елементи?</td>
    <td>it сочи END, когато...</td>
  </tr>

  <tr>
    <td>Свързан списък</td>
    <td>Един Node\*, сочещ текущия елемент</td>
    <td>Чрез ->next->next...</td>
    <td>Указателят стигне nullptr</td>
  </tr>

  <tr>
    <td>DynamicArray (идея 1)</td>
    <td>Т\*, сочещ текущия елемент</td>
    <td>Чрез вградения ++ за указатели</td>
    <td>
      Указателят стигне arr+size<br>
      (arr - указател към началния елемент на масива,
      size - броят на елементите)
    </td>
  </tr>

  <tr>
    <td>DynamicArray (идея 2)</td>
    <td>Индекс в масива и указател към първия елемент</td>
    <td>Увеличаваме индекса всеки път с 1</td>
    <td>Индекса стане size</td>
  </tr>

  <tr>
    <td>HashMap</td>
    <td>Ред и колона в таблицата, както и указател към самата таблица</td>
    <td>Увеличаваме номера на колоната с 1, ако редът свърши - минаваме на следващ в колона 0</td>
    <td>Стигнем ред table.size()</td>
  </tr>

  <tr>
    <td>Дърво</td>
    <td>Указател към текущия Node и стек от чакащи поддървета</td>
    <td>Сложно, вж. BinTree.h</td>
    <td>Указателят стане nullptr и стекът е празен</td>
  </tr>
</table>

За HashMap и втората идея за DynamicArray е необходимо да пазим указател към масива или таблицата,
защото индексите сами по себе си не носят информация за елемента.
(Хубаво знаем, че сме на ред 3 и колона 5, но ако нямаме таблицата, как ще кажем кой е елементът?)
Итераторът е отделен обект, той няма пряка видимост към структурата, която обхожда, затова трябва да му я дадем ние.
