## Абстракции

Груба дефиниция: Имаме абстракция, когато използваме нещо сложно наготово за нещо друго.
Например когато в един клас да използваме друг клас наготово. За големия клас е важно, че малкия клас работи.
Как точно са написани методите на малкия клас, не е важно за големия.

Примери за абстракции:
- В класа Product използваме класа Cost като абстракция за цена
- В класа Store използваме класовете Product и User
- Класът String може да бъде използван на много места, където имаме символен низ

Полза от абстракциите:
- Избягваме повтарянето на код - ако някъде ни трябва символен низ, просто използваме String,
не пишем навсякъде логиката за управлението на паметта за низа
- Кодът става много по-кратък
- Кодът става много по-лесен за четене и разбиране
- Като пишем големия клас, мислим за по-малко неща - напр. в Product и User, не трябва да мислим за динамичната памет,
ако ползваме String - в String сме свършили черната работа

## Правило единствено: Абстракцията трябва да е логична

За всяка член-данна на един клас трябва да звучи смислено изречението:

"Един <клас> има <член-данна>, която е <тип на данната>."

Пример за логична абстракция: Един Product има description, който е String

Пример за нелогична абстракция: Един Student има grades, което е MeteorologicalStation

## За любопитните: Проблеми с абстракциите

Има два често срещани проблема

### Липсваща абстракция

**Пример 1:** Ако в класовете Product и User ползваме гол char* за символните низове

**Проблемът:** На няколко места имаме един и същ (и то сложен) код - логиката за заделяне и изтриване на памет за низ.

**Решението:** Написваме си клас String, в който опаковаме логиката за заделяне и изтриване на памет за низ,
и използваме String в другите класове

**Пример 2:** Следният клас:

    class MusicAlbum {
        String name_of_album;       // Да речем, че имаме добре написан String
        String name_of_artist;
        int year;
        Song* songs;                // Да речем, че имаме добре написан Song
        int number_of_songs;
        int capacity_of_songs;
    public:
        // Да речем, че класът работи правилно, като в голямата четворка и в други методи
        // управляваме динамичния масив от песни
    };

**Проблемът:** Класът MusicAlbum е излишно дълъг и сложен, тъй като в него се грижим за заделянето и изтриването на памет
за масива от песни

**Частично решение:** Пишем клас SongArray, в който опаковаме логиката за масива от песни. Вместо songs, number_of_songs и
capacity_of_songs, в MusicAlbum слагаме член-данна от тип SongArray

**По-добро решение:** Пишем шаблонен клас Array, в който опаковаме логиката за динамичен масив. Вместо songs, number_of_songs и
capacity_of_songs, в MusicAlbum слагаме член-данна от тип Array<T>

### Грешна абстракция

Това е абстракция, която не е логична, например ако Student има grades, което е MeteorologicalStation

**Проблемът:** Student е силно зависим от MeteorologicalStation, а двата класа не би трябвало да имат нищо общо

Кодът се променя с времето. Напълно възможно е да поискаме:

- В MeteorologicalStation да има други данни, освен масива от числа
- В MeteorologicalStation масивът от измервания да не е просто от числа, а от по-сложни обекти (напр. за всяко измерване
да пазим и кога е било измерено)

И в двата случая промяната в MeteorologicalStation ще прее..., така де, ще се отрази зле на Student.

**Решението:** Правим grades обект от друг, по-подходящ клас, например DoubleArray, или пък Array<double>.
За да нямаме повторение на код, в MeteorologicalStation също използваме DoubleArray или Array, вместо да пазим
гол указател и два int-a.
