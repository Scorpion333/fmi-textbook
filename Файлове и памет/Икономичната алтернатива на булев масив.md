# Паметоядът, наречен масив от булеви променливи

Eдна булева променлива заема
[1 байт в паметта](https://github.com/Scorpion333/fmi-oop-2017/blob/master/Теория/Файлове%20и%20памет/Представяне%20на%20величините%20в%20паметта.md). 

Масив от 8 булеви променливи би се представил, например, така:

    Байт X      Байт Х+1    Байт X+2    Байт X+3      Байт X+4    Байт Х+5    Байт X+6    Байт X+7
    0000-0001   0000-0000   0000-0000   0000-0001     0000-0001   0000-0000   0000-0001   0000-0000.
    (True)      (False)     (False)     (True)        (True)      (False)     (True)      (False)
    
Заделят се 8 байта. Това е голямо разхищение, понеже за всеки от байтовете е съществен само последният бит.
Останалите 7 бита са похабени, а това прави 87,5% загубена памет.
Ако имахме масив не от 8, а от 8 000 000 000 булеви променливи, за тях щяхме да заделим 8 GB памет, от които 7 GB щяха да идат на вятъра.
Струва си да се помисли за

## По-пестеливо представяне на булевите масиви

Горният масив спокойно може да бъде събран в 8 бита, т.е. за него може да заделим точно 1 байт:

    10011010
    или
    01011001, ако обърнем реда, което е удобно, както се вижда по-надолу
    
01011001 всъщност е двоичното представяне на числото, в което степените на 2 съответстват на индексите на масива:

<table>
  <tr>
    <th>Индекс</th>
    <th>7</th>
    <th>6</th>
    <th>5</th>
    <th>4</th>
    <th>3</th>
    <th>2</th>
    <th>1</th>
    <th>0</th>
  </tr>
  <tr>
    <td>Стойност в масива<br>(1 = true, 0 = false)</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>Степен на две</td>
    <td>128</td>
    <td>64</td>
    <td>32</td>
    <td>16</td>
    <td>8</td>
    <td>4</td>
    <td>2</td>
    <td>1</td>
  </tr>
  <tr>
    <td>И така, числото е:</td>
    <td colspan="8">64 + 16 + 8 + 1 = 89</td>
  </tr>
</table>

Аналогично всеки всеки масив от N булеви променливи съответства на точно едно число от 0 до 2^N - 1
(това са числата, които могат да се запишат с N двоични цифри). Тук е важно да имаме предвид и размера на масива, защото,
например числото 5 = 101, може да представи всеки от следните масиви:

    1, 0, 1
    1, 0, 1, 0
    1, 0, 1, 0, 0
    1, 0, 1, 0, 0, 0
    1, 0, 1, 0, 0, 0, 0
    1, 0, 1, 0, 0, 0, 0, 0
    1, 0, 1, 0, 0, 0, 0, 0, 0
    ...
    
И така, за един булев масив е достатъчно да пазим две числа:

- това, чиито двоични цифри сътовестват на стойностите на масива
- размерът на масива

В някои случаи размерът не се пази, защото фиксиран, напр. при
[ios флаговете](https://github.com/Scorpion333/fmi-oop-2017/blob/master/Теория/Файлове%20и%20памет/Ios%20флагове%20на%20stream-овете.md).

## Работа с това представяне на масива

За проверка на стойността на всеки бит, както и за добавяне, премахване и промяна на елементи, можем да използваме
[побитовите операции](https://github.com/Scorpion333/fmi-oop-2017/blob/master/Теория/Бонус/Побитови%20операции.pdf).

## А ако масивът е много дълъг?

Числата в C++ са с крайна дължина, дори тази на unsigned long long числата е доста малка (напр. 64 бита),
за да представи масив от милиони елементи. Е, тогава можем да направим масив от числа, в който всяко да пази само няколко
от елементите на булевия масив. По този начин е реализиран стандартния vector за bool.
