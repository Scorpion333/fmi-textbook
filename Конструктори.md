# Конструктори

Конструкторът е метод, който се извиква при създаването на обект от клас (или структура, навсякъде по-долу всичко, написано
за класовете важи и при структури).

- Един клас може да има много конструктори
- При създаване на обект от класа се изпълнява точно един от конструкторите
- След това не може да се изпълни конструктор за същия обект

Смисълът е, че конструкторът конструира обекта. Може да има няколко начина за конструиране. При създаване на обект, той
трябва да се конструира по някой от тях. След като е създаден вече, не може да го конструираме отново.

## По-конкретно

Нека имаме клас Цена с две член-данни - лева и стотинки. Хубаво е да можем да създадам цена по три начина:

    int main() {
        Cost c1;            // Без данни - c1 ще стане 0 лв. и 0 ст.
        Cost c2(15);        // С 1 число - c2 ще стане 15 лв. и 0 ст.
        Cost c3(14, 99);    // С 1 число - c2 ще стане 14 лв. и 99 ст.
    }
    
За да направим това, пишем три метода с особен синтаксис, приемащи съответно 0, 1 и 2 аргумента:

    class Cost {
        // ...
    public:
        Cost() {
            lv = 0;
            st = 0;
        }
        
        Cost(int _lv) {
            lv = _lv;
            st = 0;
        }
        
        Cost(int _lv, int _st) {
            lv = _lv;
            st = _st;
        }
    }
    
Важно е всеки конструктор да има "име" същото като това на класа и да няма уточнен тип който връща

## Конструктор по подразбиране

Това е конструктор, който не приема аргументи. Когато създаваме променлива с него, НЕ ПИШЕМ ().

## Безименни обекти

Ами, това са обекти без име. За да създадем такъв, викаме някой конструктор като функция.
После може да извикваме други методи:

    cout << Cost(15).get_lv();      // Принтира се 15
    cout << Cost().get_lv();        // Принтира се 0. Тук пишем () и за този конструктор

На практика, това са константи от тип Cost (или друг клас) - по същия начин като напишем някъде в кода 18 или 'а',
създаваме безименен int със стойност 18 или безименен char със стойност 'a'.

Много е удобно функция да връща безименен обект:

    Cost sum_of_costs(Cost a, Cost b) {
        int sum_of_lv = a.get_lv() + b.get_lv();
        int sum_of_st = a.get_st() + b.get_st();
        return Cost(sum_of_lv + sum_of_st / 100, sum_of_st % 100);
    }

## Конструктор за копиране

Това е конструктор, който приема един аргумент - от същия клас.

АБСОЛЮТНО ЗАДЪЛЖИТЕЛНО е аргументът на този конструктор да е const референция (защо - ще кажем в час):

    class Cost {
        // ...
        Cost (const Cost& other) {
            lv = other.lv;
            st = other.st;
        }
    };

Той се използва всеки път, когато създаваме обект, правейки го
равен на друг обект, например в този случай:

    Cost c4(17);    // c4 се създава с друг конструктор и става 17 лв. и 0 ст.
    Cost c5 = c4;   // c5 се създава с конструктор за копиране и става 17 лв. и 0 ст.

Или когато извикваме функция, приемаща аргумент с тип Cost (или друг клас):

    int round_up(Cost cena) {   // Функция, връщаща броя левове, ако закръглим цена нагоре
        if(cena.get_st() == 0) {
            return cena.get_lv();
        }
        return cena.get_lv() + 1;
    }
    
    int main() {
        Cost c6(14,99);
        cout << round_up(c6);       // Извежда се 15. cena горе се създава с конструктора за копиране
    }                               // Аргументът на конструктора е c6
    
