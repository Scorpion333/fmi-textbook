## Особености на ператор =

## TLDR:

- В оператора= трябва да се delete-ват динамичните масиви
- Трябва да има проверка this != &other. Само ако this != &other, трябва да се трие и копира
- Трябва оператора да връща стойност от тип Класа& и тя да е *this.

Пример:

    class Product {
        char* name;
        Cost cost;
        char* description;
        int quantity;

        // ...

        Product& operator=(const Product& other) {
            if (this != &other) {
                delete[] name;
                delete[] description;

                name = new char[strlen(other.name) + 1];
                strcpy(name, other.name);

                cost = other.cost;

                description = new char[strlen(other.description) + 1];
                strcpy(description, other.description);

                quantity = other.quantity;
            }
            return *this;
        }
    };

## Защо delete?

Оператор = се използва, когато имаме два **вече конструирани** обекта и искаме данните на единия да станат като на другия:
Пример:

    Product a, b;
    // ...
    a = b;

В този пример искаме името, цената, описанието и количеството на *a* да станат като на *b*. Добре, ама *a* вече си има име,
цена, описание и количество, като името и описанието са в масиви в динамичната памет. Ако просто насочим указателите в *a*
към нова памет за името и нова памет за описанието, старото име и старато описание ще останат в паметта и ще я задръстват.
След 1 000 000 присвоявания на обекти от тип Product, в паметта ще има 2 000 000 излишни масива. Дори във всеки от тях да има
само по 10 символа, това са 20 MB.

За да нямаме задръстване на паметта, трябва да си изхвърляме боклука

## Защо this != &other? Заради случая a = a

Стойността на this e адреса на левия обект. Стойността на &other е адреса на десния обект

Така е, понеже this е указател към левия обект (x = y e просто кратък запис за x.operator=(y)).

&z по принцип е адреса на z, но ако z е референция, &z е адреса на *това към което z сочи*.
other e референция към десния обект, значи &other е адреса на десния обект.

this == &other <==> адреса на левия обект съвпада с адреса на десния <==> двата са един и същи обект

Рядък случай, но все пак възможен (напр.: *a* = *c*, където c e референция към някой обект, който може да е *а*).
E, какво би трябвало да направим, ако обект става равен на себе си?

Ами, нищо. Да копираме данните обекта в самия него е малко безсмислено. Това е като да се явиш на изпит по ООП,
да го вземеш, и после пак да ходиш на изпит. Или да напишеш в някоя функция return; return;

### "Мързи ме да напиша if(this != &other)"

Тогава ако обект тръгне да става равен на себе си, ще се случат много лоши неща - ще му delete-неш данните,
после ще искаш данните му да станат копия на данните на other, ама other e същия обект, т.е. other e с изтрити данни...

А, и ако те мързи толкова много, не ставай програмист

## Защо Product& и return *this; ?

*this е референция към левия обект, т.е. ние връщаме препратка към левия обект, което си е от тип Product&.

Това го правим по две причини:

1. Ако оператора = връща резултат, можем да напишем:

<span></span>

    Product a, b, c;
    // ...
    a = b = c;

Което е същото като:

    a = (b = c);

Резултатът: и *a*, и *b* ще станат равни на *c*.

Също може да подадем a = b като аргумент на функция. Понякога просто е удобно да се правят присвоявания в движение.

2. Наложено е като практика

Някои практики в програмирането не са много функционални, но просто са разпространени. Ако не ги спазваш, това се счита за лош стил и би затруднило работата ти с други хора
