# Защо nullptr/NULL  не е добро представяне на празен масив

Указател, замислен да сочи към масив, **никога** не трябва да бъде насочван към нулевия адрес.

Правилно е да заделим памет за масива и да насочим указателя към заделения буфер.
А ако си имаме работа със символен низ, и да добавим '\0' в началото на масива.

За nullptr не са дефинирани нито оператора [], нито функциите от cstring, което e доста неудобно,
защото се налага всеки път да разглеждаме празния масив като специален случай. А това е излишно.

    // Добрият начин да инициализираме празен масив
    
    int* good_arr = new int[16];        // На практика всяко положително число върши работа, но е разпространено да се избира степен на 2
    
    good_arr[0] = 21;                   // Добавянето на елемент на позиция 0 е лесно, безопасно и става на 1 ред
    
    
    // Добрият начин да инициализираме празен низ
    
    char* good_str = new char[1];       // Според ситуацията може да е добре да заделим повече памет,
    good_str[0] = '\0';                 // но със сигурност ще ни трябва място поне за '\0'

    cout << "Length: " << strlen(good_str);               // strlen връща 0 за нашия празен низ
    
    char* happy_copy = new char[strlen(good_str) + 1];    // И изобщо не се налага да мислим дали низът ни ще е празeн
    strcpy(happy_copy, good_str);                         // Всички функции работят коректно
    
Не е зле за код с динамични масиви. Да видим какво става с nullptr.
    
    // Лошият начин да инициализираме празен масив
    
    int* bad_arr = nullptr;
    
    if(bad_arr == nullptr) {        // Налага се да проверяваме дали случайно указателят не е nullptr
        bad_arr = new int[16];      // И какво стана? Пак трябваше да заделим памет!
    }
    bad_arr[0] = 21;                // 4 реда код за едното слагане на елемент на позиция 0!
    
    
    // Лошият начин да инициализираме празен низ
    char* bad_str = nullptr;
    
    // Принтиране на дължината
    cout << "Length: ";
    if(bad_str == nullptr) {
        cout << 0;
    }
    else {
        cout << strlen(bad_str);
    }
    
    // Копиране
    char* miserable_copy;
    if(bad_arr == nullptr) {
        miserable_copy = nullptr;    // Програмистът, насочил bad_str към nullptr със сигурност би запратил там и другия указател
    }
    else {
        char* miserable_copy = new char[strlen(bad_str) + 1];
        strcpy(miserable_copy, bad_str);
    }
    
Грозотия. Фактът, че лошият пример заема два пъти повече място от добрия, е достатъчно красноречив.