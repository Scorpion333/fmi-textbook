# Как се прави разширяващ се масив

Задачата: да поддържаме динамичен масив, в който да може да добавяме произвелен брой елементи.

Очевидно не може просто да кажем нещо от рода на:

    double arr[100];

защото при добавянето на 101-вия елемент паметта ще се напълни.
Ще трябва да заделим памет в хийпа и при всяко нейно запълване да заделяме нова памет.
Въпросът е колко да е тази памет и как точно да реализираме добавянето на елемент.

Има няколко основни идеи

## Идея 1 - всеки път нова памет

За един масив е важно да пазим елементите в него и колко са на брой, така че е достатъчно
през цялото време заделената памет да е точно толкова голяма, колкото са елементите в масива.
И да пазим този размер в една променлива (size).
Всяко добаване на елемент би изглеждало така:

    Нека имаме масив с 5 елемента.
    arr -> [11, 12, 13, 14, 15]

    Искаме да добавим още един, но няма място за него в края на масива.
    arr -> [11, 12, 13, 14, 15] ? ? ? ?
                                ^
                                Паметта тук не сме я заделили и нямаме право да я ползваме.

    Трябва да заделим нова памет чрез помощен указател.
    Естествено, избираме новият буфер да е с 1 по-дълъг.
    arr    -> [11, 12, 13, 14, 15]
    helper -> [ ?,  ?,  ?,  ?,  ?,  ?]

    Копираме всичко в новата памет (стават общо 5 копирания на елементи) и добавяме новия елемент накрая.
    arr    -> [11, 12, 13, 14, 15]
    helper -> [11, 12, 13, 14, 15, 16]

    Сега трябва да изтрием старата памет, да не заема място.
    arr    -> ?
    helper -> [11, 12, 13, 14, 15, 16]

    И да насочим arr към новата памет. helper също ще сочи натам, но това не е проблем.
    arr -> [11, 12, 13, 14, 15, 16]

## Реализация на идея 1

Нека имаме клас с такъв масив за член-данна:

    class MyClass {
        double* arr;
        int size;

    public:
        MyClass() {
            size = 0;
            arr = new double[size];     // Въпреки че нямаме елементи, трябва да насочим arr нанякъде
        }                             // за да може да го delete-нем по-късно

        MyClass(const MyClass& other) {
            size = other.size;
            arr = new double[size];
            for(int i = 0; i < size; i++) {
                arr[i] = other.arr[i];
            }
        }

        // ...

        void add_element(double x) {
            double* helper = new double[size + 1];       // Заделяме нова памет, за 1 елемент повече

            for(int i = 0; i < size; i++) {              // Копираме всичко от старата в новата памет
                helper[i] = arr[i];
            }
            helper[size] = x;                            // Добавяме и новия елемент

            delete[] arr;                                // Трием старата памет, вече не ни трябва
            arr = helper;                                // Насочваме указателя към новия масив

            size++;                                      // И си обновяваме и размера
        }
    }

Идеята работи, обаче програмата ще върви меко казано бавно.

Всеки път при добавяне на елемент, ако в него има N елемента се извършват N + 1 присвоявания на стойности.
Ако започнем с празен масив и добавим 1000 елемента в него, горният прооцес ще се изпълни 1000 пъти и ще са необходими

    (0 + 1) + (1 + 1) + (2 + 1) + ... + (999 + 1) = 1 + 2 + ... + 1000 = 500500

присвоявания.

## Идея 2 - нова памет само от време на време

Тя е да направим така, че през повечето време да има празно място зад масива и да заделяме нова памет само в редки случаи.
Това може да стане, например, ако в началото заделим памет за k елемента (k - някакво положително число, често се избира
степен на 2) и когато тя се напълни, заделим по-голяма памет, после още по-голяма и т.н.
Колко по-голяма да е всяка следваща памет? Може да е всеки път с 10 елемента по-голяма, или пък всеки път с 20 елемента
по-голяма. Но най-добрата идея е да е двойно по-голяма:

    Нека изберем k = 4. Започваме с памет за 4 елемента, без да им даваме стойност.
    arr -> [ ?,  ?,  ?,  ?]

    Добавяме елемент:
    arr -> [11,  ?,  ?,  ?]

    Още един:
    arr -> [11, 12,  ?,  ?]

    И още един:
    arr -> [11, 12, 13,  ?]

    И още един:
    arr -> [11, 12, 13, 14]

    Дотук 4 присвоявания за 4 елемента. По другия начин щяха да са 10 присвоявания.

    Сега вече няма повече място. Ако искаме да добавим още нещо, трябва да заделим нова памет.
    arr    -> [11, 12, 13, 14]
    helper -> [ ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    arr    -> [11, 12, 13, 14]
    helper -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]

    arr    -> ?
    helper -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]

    arr    -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]

    Супер! Вече има място. Да добавим един елемент.
    arr    -> [11, 12, 13, 14, 15,  ?,  ?,  ?]

    И още един:
    arr    -> [11, 12, 13, 14, 15, 16,  ?,  ?]

    И още един:
    arr    -> [11, 12, 13, 14, 15, 16, 17,  ?]

    И още един:
    arr    -> [11, 12, 13, 14, 15, 16, 17, 18]

    Пак стигнахме до момент, в който няма повече място. Отново заделяме нова памет.
    arr    -> [11, 12, 13, 14, 15, 16, 17, 18]
    helper -> [ ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    arr    -> [11, 12, 13, 14, 15, 16, 17, 18]
    helper -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    arr    -> ?
    helper -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    arr    -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    Отново има място! Да добавим елемент още веднъж.
    arr    -> [11, 12, 13, 14, 15, 16, 17, 18, 19,  ?,  ?,  ?,  ?,  ?,  ?,  ?]

    И още веднъж.
    arr    -> [11, 12, 13, 14, 15, 16, 17, 18, 19, 20,  ?,  ?,  ?,  ?,  ?,  ?]

    И т.н.

Тъй като всеки път, когато заделяме памет, заделяме двойно повече от преди, а 1000 е приблизително 2^10,
за слагането на 1000 елемента в масива ще са необходими не повече от 10 нови заделяния на памет.
А присвояванията ще са само около 2000 (защо?). Доста по-добре от 1000 заделяния на памет с 500500 присвоявания.

## Реализация на добрата идея

Този път освен указателя, ни трябват две помощни числа:

- size - броят на елементите, вкарани в масива
- capacity - памет за колко елемента сме заделили

<span></span>

    class MyClass {
        double* arr;
        int size;
        int capacity;

    public:
        MyClass() {
            size = 0;
            capacity = 8;
            arr = new double[capacity];       // Заделяме памет за capacity елемента,
        }                                     // но не им даваме стойности

        MyClass(const MyClass& other) {
            size = other.size;
            capacity = other.capacity;

            arr = new double[capacity];       // Заделяме памет за capacity елемента,
                                              // но използваме само size места от нея
            for(int i = 0; i < size; i++) {
                arr[i] = other.arr[i];
            }
        }

        // ...

        void add_element(double x) {

            if(size == capacity) {                        // Само ако вече сме запълнили паметта...
                capacity = capacity * 2;
                double* helper = new double[capacity];    // ...заделяме нова - този път за двойно повече елементи

                for(int i = 0; i < size; i++) {
                    helper[i] = arr[i];
                }
                helper[size] = x;                    

                delete[] arr;                         
                arr = helper;                         

                size++;
            }

            else {                          // Ако пък имаме памет, всичко е топ!
                arr[size] = x;
                size++;
            }
        }
    }
