# Командите, започващи с \#

\#include, #define, #pragma once - това са т.нар. предпроцесорни директиви (preprocessor directives).
Те представляват специални команди, които се изпълняват преди същинското
[компилиране](https://github.com/Scorpion333/fmi-oop-2017/blob/master/Теория/Компилиране%20и%20%23-команди/Какво%20всъщност%20е%20компилирането.md)
на програмата. Те обработват кода на синтактично ниво, изпълнявайки "copy-paste" операции върху текста, например.

Някои по-често използвани команди са:

## #include

След #include се посочва хедър файл. Съдържанието на хедъра се копира и се поставя във файла, в който сме написали #include.
(По-точно, компилаторът започва да работи с версия на другия файл, в която на мястото на #include-a, е поставен хедъра.)
По този начин не се налага компилаторът да чете и да превежда хедъри, които не се използват - например онези хедъри от стандартната
библиотека, които не ни трябват в конкретния проект.

Тук се появява друг проблем - include-ването на един хедър в няколко файла означава прочитане на хедъра повече от веднъж -
това води не само до загуба на време, но и до грешки, предизвикани от повторното дефиниране на едни и същи класове и функции.
Заобикаляме това препятствие с помощта на други команди.

## #define

Това е начин да дефинираме константа. Правим го без да пишем тип:

    #define CAPACITY 100
    
\#define действа по следния начин: навсякъде в кода, където се среща низът "CAPACITY", той се заменя с низа "100", след което програмата
се компилира все едно навсякъде е пишело просто 100.

Не е същото при другия начин да дефинираме константа (const unsigned CAPACITY = 100) - тогава се заделя памет и се създава истинска
величина с тип и стойност. Често няма съществена разлика в крайния резултат, но все пак #define и const не работят еднакво.

Аз предпочитам const пред #define.

## #pragma once

Поставена в началото на хедър файл, тази директива казва на компилатора: "Компилаторе, не чети този хедър повече от веднъж".
Така, ако компилаторът стигне до файл, в който хедърът е #include-нат, но види, че този хедър вече е бил прочетен, няма да го
чете и копира отново.

Използването на #pragma once доста удобно, но не е стандартно и не всички компилатори поддържат тази директива.
Ако искаме да сме сигурни, че проектът ще се компилира навсякъде, използваме т.нар. include guards, а именно конструкцията:

## #ifndef - #define - #endif

Пишат се в началото и в края на хедър файла, ето така:

    #ifndef PROGRAMMER_H
    #define PROGRAMMER_H
    
    class Programmer {
        // ...
    };
    
    #endif
    
"ifndef" идва от If Not Defined. Смисълът на #ifndef е следният - ако не сме дефинирали нещо, наречено PROGRAMMER_H,
се изпълнява кодът надолу до #endif.

Това, което прави #define PROGRAMMER_H е да дефинира PROGRAMMER_H. (Понеже в класа Programmer всъщност не ни трябва константа с това име,
"константата" PROGRAMMER_H е без стойност.)

И така, когато компилаторът чете Programmer.h за първи път, PROGRAMMER_H не е дефинирана, затова се изпълнява кодът до края на хедъра,
а именно - дефинират се класа Programmer и празната константа PROGRAMMER_H.

Когато компилаторът започне да чете хедъра за втори път, той ще види, че PROGRAMMER_H е дефинирана, затова няма да изпълни кода
между #ifndef и #endif. Така класът няма да бъде дефиниран отново.

На мястото на PROGRAMMER_H би могъл да стои и друг стринг, но е разпространена практика да се избира ИМЕТОНАКЛАСА_H за тази цел.