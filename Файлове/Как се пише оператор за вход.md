# Как се пише оператор >>

Кагато дефинираме на оператор >> за клас, обикновено очакваме той да работи така:

- имаме файл/поток, в който са записани данни за обект от класа
- прочитаме данните
- записваме ги в обекта, стоящ отдясно на оператора

## "Стандартни" класове

Повечето класове, за които бихме писали оператор >>, се състоят от числа и низове.

Пример: клас Служител с член-данни име, ЕГН, години стаж и заплата.

    class Employee {
        char* name;         // Произволна дължина
        char egn[11];       // 11, защото трябва да има място за '\0' в края
        int years;
        double salary;
        
        // Да приемем, че класът има добре написани сетъри, гетъри и голяма 4-ка
    }
    
## Един удобен формат за сериализация

Има много начини да запишем еднозначно тези данни, но една доста универсална и лесна за разбиране идея е: всяка член-данна на отделен ред, т.е.:

    Fernando
    9103025572
    7
    1996.04
    
Възпроизвежда я следният оператор за изход (много е важно и двата оператора да работят с един и същи формат на сериализация):

    ostream& operator << (ostream& out, const Employee& employee) {
        out << employee.name << '\n'
            << employee.egn << '\n'
            << employee.years << '\n'
            << employee.salary;
        return out;
    }

## Операторът >>

Числата и нединамичните низове могат да се "cin-ват" директно. С динамичните масиви има два стандартни начина да се подходи:

### Вариант 1: Помощен нединамичен масив
    
    istream& operator >> (istream& in, Employee& employee) {
        
        char name[500];                 // Избираме "достатъчно голямо" число 
        in >> name;                     // Прочитаме името по стандартния начин
                                        // (или с getline, ако има вероятност да съдържа интервали)
                                        
        employee.set_name(name);        // Добре написан сетър ще направи каквото трябва тук
        
        in >> employee.egn              // Останалото е тривиално
           >> employee.years
           >> employee.salary;
           
        return out;
    }
    
### Варинт 2: Четене символ по символ и преоразмеряване в движение
    
    istream& operator >> (istream& in, Employee& employee) {
        
        int capacity = 16;                          // Всяко малко положително число върши работа
        char name = new char[capacity + 1];         // За начало създаваме масив с място за 16 символа (+1 за '\0')
        int i = 0; 
              
        while(in.peek() != '\n' && !in.eof()) {     // Ще четем, докато не видим знак за нов ред или края на файла
            if(i == capacity) {                     // Ако буферът се напълни, съвдаваме нов, два пъти по-дълъг
                name[i] = '\0';                     // strcpy изисква '\0' в края на копирания низ
                capacity *= 2;                      
                char* tеmp = new char[capacity];
                strcpy(tеmp, name);
                delete[] name;         
                name = temp;
            }                                       // Сега е сигурно, че има място, затова
            name[i] = in.get();                     // записваме следващия символ и продължаваме нататък
            i++;
        }
        name[i] = '\0';                             // new char[] НЕ слага '\0', затова трябва да я сложим ръчно
        
        employee.set_name(name);                    
        delete[] name;                              // За да няма memory leak.
        
        in >> employee.egn                          // Останалото е като преди
           >> employee.years
           >> employee.salary;
        
        in.get();                                   // Почти винаги има знак - интервал или нов ред,
                                                    // който може да съзададе проблеми при четенето на следващ служител.
        return out;
    }
    
В по-редки и сложни ситуации и възможно да потрябва друго по-специално действие, но това е малко вероятно.