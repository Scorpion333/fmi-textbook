# Правила за писане на кода по ООП

## class vs struct

1. Почти винаги пишем класове
2. В редки случаи пишем struct (кога - ще видим по-натам)

## Член-данни и методи (член-функции)

1. Всички член-данни са private
2. Почти всички методи са public
3. Някои методи са private (кои - ще видим по-натам)

## Get-ъри и Set-ъри

1. Get-ърът е метод, който връща стойността на някоя член-данна. Името му започва с get
2. Set-ърът е метод, който не връща нищо и сменя стойността на някоя член-данна. Името му започва със set
3. Пишем get-ъри за тези член-данни, за които ни трябват
4. Пишем set-ъри за тези член-данни, за които е безопасно
<br>(Най-вече когато член-данните са независими една от друга)

В началото ги пишем за почти всичко, с цел упражнение

## Константи и референции

1. Всеки метод, който не променя обекта, т.е. не променя никоя член-данна, се маркира с const между кръглите и къдравите скоби.

Примери:

    int get_quantity() const {
        return quantity;
    }

    // ...

    bool matches(char* _username, char* _password) {
        return strcmp(username, _username) == 0
            && strcmp(password, _password) == 0;
    }

Сетърите и конструкторите пък са примери за не-const методи

2. Гетър, който връща указател, трябва връща указател към константа, т.е. указател с const отпред

<span></span>

    const char* get_username() const {
        return username;
    }

3. Аргумент на функция, който е от тип клас и не се променя във функцията, трябва да е const&

<span></span>

    Cost sum_of_costs(const Cost& a, const Cost& b) {
        int sum_of_lv = a.get_lv() + b.get_lv();
        int sum_of_st = a.get_st() + b.get_st();
        return Cost(sum_of_lv + sum_of_st / 100, sum_of_st % 100);
    }

4. Аргумент, който е от прост тип (int, bool, char, ...) и не се променя във функцията, го оставяме просто int, bool, ...

<span></span>

    void set_quantity(int _quantity) {
        quantity = _quantity;
    }

## Смисъл на правилата за константи и референции

1. Трябва да отбележим методите, които не променят обекта, понеже за константи обекти и const референции можем да викаме
само const методи

<span></span>

    int some_function(const Cost& a) {
        a.get_lv();     // ОК
        a.set_lv(13);   // Нелегално
        // ...
    }

2. Ако гетър връща гол указател, може през указателя да променим член-данната

<span></span>

    Product product;
    product.set_name("Sirene");     // Това е ОК
    product.get_name()[3] =  'i';   // Това обаче НЕ Е ОК - не трябва да може с гетъра да направим името Sirine

Ако get_name() връща const char*, третият ред няма да се компилира

3. При всяко извикване на функция всеки от аргументите ѝ става копие на това, което е подадено, т.е. тук
*c* става копие на *cost*, а *n* става копие на *number*

<span></span>

    Cost operator*(Cost c, int n) {
        // ...
    }

    int main() {
        Cost cost(19, 3);
        int number = 2019;

        Cost cost2 = cost * number;
    }

Това не е проблем за числото n, но е лошо, че за *c* се заделя павече памет - за един Cost. С по-големи класове
копирането става още по "скъпо", затова го избягваме като правим аргумента референция.
(1 референция е много по-малка, все пак референцията е указател, а указателят е число)

Но с референцията губим друго - сигурността, че аргументът няма да се промени във функцията.
Затова освен & слагаме и const - const референцията хем сочи обекта, хем не може да го промени

    Cost operator*(const Cost& c, int n) {
        // ...
    }

4. Докато обектите от класове съдържат по няколко член-данни и могат да заемат много байтове в паметта,
малките типове - int, char, bool, ... заемат памет горе-долу колкото за един указател (даже по-малко, в някои случаи),
така че употреба на const& не би ни спестила памет

# Правилата ще бъдат допълвани!
