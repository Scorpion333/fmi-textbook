# Правила за писане на кода по ООП

Тези правила понякога се нарушават, но само от хора, които наистина знаят какво правят!

## class vs struct

1. Почти винаги пишем класове
2. В редки случаи пишем struct (кога - ще видим по-натам)

## Член-данни и методи (член-функции)

1. Всички член-данни са private
2. Почти всички методи са public
3. Някои методи са private (кои - ще видим по-натам)

## Get-ъри и Set-ъри

1. Get-ърът е метод, който връща стойността на някоя член-данна. Името му започва с get
2. Set-ърът е метод, който не връща нищо и сменя стойността на някоя член-данна. Името му започва със set
3. Пишем get-ъри за тези член-данни, за които ни трябват
4. Пишем set-ъри за тези член-данни, за които е безопасно
<br>(Най-вече когато член-данните са независими една от друга)

В началото ги пишем за почти всичко, с цел упражнение

## Константи и референции

1. Всеки метод, който не променя обекта, т.е. не променя никоя член-данна, се маркира с const между кръглите и къдравите скоби.

Примери:

    int get_quantity() const {
        return quantity;
    }

    // ...

    bool matches(char* _username, char* _password) {
        return strcmp(username, _username) == 0
            && strcmp(password, _password) == 0;
    }

Сетърите и конструкторите пък са примери за не-const методи

2. Гетър, който връща указател, трябва връща указател към константа, т.е. указател с const отпред

<span></span>

    const char* get_username() const {
        return username;
    }

3. Аргумент на функция, който е от тип клас и не се променя във функцията, трябва да е const&

<span></span>

    Cost sum_of_costs(const Cost& a, const Cost& b) {
        int sum_of_lv = a.get_lv() + b.get_lv();
        int sum_of_st = a.get_st() + b.get_st();
        return Cost(sum_of_lv + sum_of_st / 100, sum_of_st % 100);
    }

4. Аргумент, който е от прост тип (int, bool, char, ...) и не се променя във функцията, го оставяме просто int, bool, ...

<span></span>

    void set_quantity(int _quantity) {
        quantity = _quantity;
    }

5. Ако функция приема указател към масив и масивът не се променя вътре, указателят да е const*:

<span></span>

    void set_name(const char* _name) {
        strcpy(name, _name);        // _name не се променя тук
    }

##  Масиви като член-данни

1. За символен низ пазим една член-данна

<span></span>

    class Product {                       class Product {
        char name[128];                       char* name;
        Cost cost;                            Cost cost;
        char description[128];     или        char* description;
        int quantity;                         int quantity;
    public:                               public:
        // ...                                // ...
    }                                     }

2. За друг масив пазим и брой на елементите в отделна член-данна. За динамичен масив е добре
да пазим и член-данна за капацитета на масива, т.е. за колко елемента имаме памет в масива

    class Student {                       class Student {
        double grades[100];                   double* grades;  
        int number_of_grades;      или        int number_of_grades;
                                              int capacity_of_grades;
    public:                               public:   
        // ...                                // ...
    }                                     }

3. НИКОГА не правим указател, замислен да сочи масив, nullptr!
[По-подробно](https://github.com/Scorpion333/fmi-textbook/blob/master/Динамични%20масиви/Защо%20nullptr%20е%20лош%20за%20празен%20масив.md)

3. Имаме ли символен низ, пишем конструктор по подразбиране, който го прави празен, като слага \0 най-отпред

// TODO: Довърши тази част

## Динамична памет

Ако в клас има динамична памет, то...

1. Трябва да има и голяма четворка (канонични методи или канонично представяне) -
конструктор по подразбиране, конструктор за копиране, оператор = и деструктор

2. В конструкторите се заделя памет, без да се трие (няма нищо за триене)

3. В деструктора се delete-ва цялата динамична памет. И не се случва нищо друго

4. В оператора= се трие старата памет и се заделя нова

5. В другите методи, които променят "динамични" член-данни, също се трие старата памет и се заделя нова

6. Винаги трябва член-данните да са във валидно състояние. **Във всеки конструктор всяка член-данна
трябва да се инициализира**

7. Създаваме празен символен низ като **заделяме памет** и казваме началния символ да е '\0'

8. Създаваме празен масив от друг тип като **заделяме памет** и дадем стойност 0 на член-данната за брая на елементите

## Смисъл на правилата за константи и референции

1. Трябва да отбележим методите, които не променят обекта, понеже за константи обекти и const референции можем да викаме
само const методи

<span></span>

    int some_function(const Cost& a) {
        a.get_lv();     // ОК
        a.set_lv(13);   // Нелегално
        // ...
    }

2. Ако гетър връща гол указател, може през указателя да променим член-данната

<span></span>

    Product product;
    product.set_name("Sirene");     // Това е ОК
    product.get_name()[3] =  'i';   // Това обаче НЕ Е ОК - не трябва да може с гетъра да направим името Sirine

Ако get_name() връща const char*, третият ред няма да се компилира

3. При всяко извикване на функция всеки от аргументите ѝ става копие на това, което е подадено, т.е. тук
*c* става копие на *cost*, а *n* става копие на *number*

<span></span>

    Cost operator*(Cost c, int n) {
        // ...
    }

    int main() {
        Cost cost(19, 3);
        int number = 2019;

        Cost cost2 = cost * number;
    }

Това не е проблем за числото n, но е лошо, че за *c* се заделя павече памет - за един Cost. С по-големи класове
копирането става още по "скъпо", затова го избягваме като правим аргумента референция.
(1 референция е много по-малка, все пак референцията е указател, а указателят е число)

Но с референцията губим друго - сигурността, че аргументът няма да се промени във функцията.
Затова освен & слагаме и const - const референцията хем сочи обекта, хем не може да го промени

    Cost operator*(const Cost& c, int n) {
        // ...
    }

4. Докато обектите от класове съдържат по няколко член-данни и могат да заемат много байтове в паметта,
малките типове - int, char, bool, ... заемат памет горе-долу колкото за един указател (даже по-малко, в някои случаи),
така че употреба на const& не би ни спестила памет

# Правилата ще бъдат допълвани!
