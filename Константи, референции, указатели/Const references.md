# Const references

Те могат да сочат както към константи, така и към променливи.
Дефинират се така:

    const int NINE = 9;
    int ten = 10;
    const int& ref_9 = NINE;
    const int& ref_10 = ten;
    
Не можем да променим стойност през такава референция, дори тя да сочи към променлива.
От следващите 4 реда само един е легален:

    NINE++;       // Нелегално - NINE е константа и не може да се променя. 
    ref_9++;      // Нелегално - ref_9 е const референция и не можем да променим стойност през нея. 
    ten++;        // ОК - ten e променлива и можем да и сменим стойността.
    ref_10++;     // Нелегално - ref_10 е const референция и въпреки че сочи към променлива,
                  // не можем да променим стойност през нея. 

В случай, че const референцията сочи към обект от клас, можем да викаме само методите, отбелязани с const:

    Vector3D {
        // ...
        void set_x(double _x) {
            x = _x;
        }
        double get_x() const {
            return x;
        }
    };
    
    int main() {
        Vector3D vec(1,2,3);
        const Vector3D& ref = vec;
        cout << ref.get_x();       // Ок - викаме const метод за const референция.
        ref.set_x(4);              // Грешно - не можем да извикаме метод, който не е означен с const.
    }

## Const references във функции

Const референциите, както и обикновените референции, се използват най-вече когато подаваме аргументи на функции, 
за да не се копират данните (особено ако аргументът е обект от клас).

Когато дефинираме функция, приемаща аргумент като обикновена референция, можем да подаваме само променливи и можем да сменим стойността
на променливата вътре във функцията (ако променливата е обект от клас, можем да викаме всеки от методите му).

Когато дефинираме функция, приемаща аргумент като const референция, можем да подаваме както променливи, така и константи и
не можем да променяме аргумента вътре във функцията (ако аргументът е от клас, можем да викаме само const методите му).

    int digits_sum(const int& n) {
        int sum = 0;
        while(n > 0) {
            sum += n % 10;
            n /= 10;        // Грешно - n не може да се променя.
        }
        return sum;
    }
    
Можем да подадем анонимна константа:

    int cube(const int& x) {
        return x * x * x;
    }
    int main() {
        cout << cube(10);     // ОК - колкото и (може би) странно да изглежда на пръв поглед...
    }

Практиката е да:

- подаваме обикновена референция, когато функцията може да промени аргумента (и искаме той да се промени) - тогава не можем да подаваме константи.
- подаваме const референция, когато функцията не променя аргумента по никакъв начин - тогава е ОК да се подават константи.
