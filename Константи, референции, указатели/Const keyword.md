# Ключовата дума const

Пишем const, когато искаме да уточним, че нещо няма да се променя. Най-основната употреба на const е
когато дефинираме именувани константа:

    const  double  PI  =  3.14;    
    const  int  MAX_SIZE  =  100;
    const  Vector3D  MY_FAVOURITE_VECTOR  =  Vector3D (3, 4, 5);
    const  String  HELLO ("Hello World!");

Това прилича на дефинирането на променлива, само че задължително трябва да дадем стойност
(ако констанатата е обект от клас - това става чрез викане на конструктор).
Тази стойност не може да бъде променяна след това. Разпространена практика е на константите
да се дават имена в стил UPPERCASE\_SEPERATED\_BY\_UNDERSCORES.

## Константни обекти

На константен обект от клас можем да викаме само част от методите на класа - тези, които сме маркирали
като непроменящи обекта. Това става с написване на const преди отварящата скоба:

    class Vector3D {
        // ...
        double get_x() const {
            return x;
        }
        void set_x(double _x) {
            x = _x;
        }
    };
    int main() {
        const Vector3D GOOD_VECTOR = Vector3D(3, 4, 5);
        cout << GOOD_VECTOR.get_x();    // Ок, get_x е const метод
        GOOD_VECTOR.set_x();            // Грешно - set_x не е const метод и този ред
                                        // няма да се компилира
        return 0;
    }

## Константи и референции

Обикновените референции не могат да сочат константи, само променливи.
Не можем да напишем това:

    const int SIX = 6;
    int& ref = SIX;

Нито това:

    int square(int& n) {
        return n * n;
    }
    int main() {
        const int NINE = 9;
        int a = square(NINE);
    }

В С++ обаче има друг вид референции - const references. Те могат да сочат както към константи, така и към променливи.

## Върнатите стойности на функциите се държат като константи

Т.е. вярно е, че:

- обикновена референция не може да сочи към върната стойност на функция
- const референция може да сочи към върната стойност от функция
- ако функция връща обект от клас, за него можем да викаме само const методи

Примери:

    int square(int& n) {
        return n * n;
    }
    int cube(const int& x) {
        return x * x * x;
    }
    int sum(const int& a, const int& b) {
        return a + b;
    }
    
    Vector3D operator - (const Vector3D& v1, const Vector3D& v2) {
        // ...
        return result;
    }
    
    int main() {
        cout << cube(10);
        Vector3D vec1, vec2;
        cin >> vec1 >> vec2;
        cout << (vec1 - vec2).get_x();  // Ок, можем да поискаме някоя координата на 
                                        // вектора, получен от изваждането на двуги два.
        (vec1 - vec2).set_x(4);         // Грешно - не можем да "променим разликата" на два вектора,
                                        // без да променим тях самите. Това е напълно безсмислено.
    }

Горните факти са в сила, освен в случаите, когато функцията връща указател или референция.