# Функции, пренасочващи указател

## Какво е пренасочване

Пренасочваме указател <=> караме указателя да започне да сочи другаде.

Това с става с написване на =, тъй като **стойността на един указател е адресът, към който той сочи**, т.е.

**за да се пренасочи указател, трябва да му дадем нова стойност**.

Пример:

    double d1 = 5.6;
    double d2 = 7.8;
    
    double* p = &d1;    // Тук насочваме указателя към d1
    p = &d2;            // Тук го пренасочваме към d2
    
    cout << *p;         // 7.8
    
## Проблемът с функциите

Ако една функция приема int, на който даваме нова стойност вътре в нея, при всяко нейно извикване се създава
**копие** на int-а и във функцията **се променя само копието**.

Ако една функция приема double, на който даваме нова стойност вътре в нея, при всяко нейно извикване се създава
**копие** на double-а и във функцията **се променя само копието**.

По същия начин, ако една функция приема указател, на който даваме нова стойност вътре в нея, при всяко нейно
извикване се създава **копие** на указателя и във функцията **се променя само копието**.

## Решението

Ако искаме да подадем int, на който да дадем нова стойност и той да остане променен след функцията,
подаваме референция към int-a, т.е. пишем int&.

Аналогично, ако искаме да подадем указател, на който да дадем нова стойност и той да сочи към новото място след
функцията, подаваме референция към указателя, т.е. пишем *&.

Пример:

    // Функция, премахваща първия елемeнт на свързан списък
    void remove_first_element(Node*& start) {
        Node* old_start = start;
        start = start->next;
        delete old_start;
    }
