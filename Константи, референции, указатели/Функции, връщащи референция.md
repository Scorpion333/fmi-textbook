# Функции, връщащи референция

За да накараме функция да връща референция, трябва просто да напишем & след типа на функцията.

Когато се връща референция, можем да променяме стойността след изпълнението на функцията.
Често това се използва, когато пишем метод на клас, връщащ член-данна или самия обект (*this).

    class Circle {
        unsigned radius;
    public:
        void  set_radius (unsigned _radius) {
            radius = _radius;
        }
        unsigned&  get_radius() {
            return radius;
        }
    }
    int main() {
        Circle c;
        c.set_radius(5);
        cout << c.get_radius();     // Извежда се 5 - можем да използваме гетъра за достъп до стойността,
                                    // както обикновено.
        c.get_radius() = 7;         // Обаче, заради референцията, можем и да сменим стойността през него!
        cout << c.get_radius();     // Извежда се 7.
    }

Метод, връщащ референция, не трябва да е const метод, защото обектът може да се промени след него.
(По принцип няма смисъл и гетърът да върши работата и на сетъра, това е само пример.)

Друг случай, в който е удачно да се връща референция, е при дефиниране на някои оператори, които биха могли да са void,
но е удобно да имат върната стойност. Например:

    class String {
        // ...
        String& operator = (const String& other) {
            if(this != &other) {
                delete[] arr;
                arr = new char[strlen(other.arr) + 1];
                strcpy(arr, other.arr);
            }
            return *this;
        }
        String& operator = (char* _arr) {
            delete[] arr;
            arr = new char[strlen(_arr) + 1];
            strcpy(arr, _arr);
            return *this;
        }
        // ...
    };
    ostream& operator << (ostream& out, const String& str) {
        out << str.arr;
        return out;
    }
    
## Защо << връща ostream&

Какво печелим от това, че << връща референция към stream-a? Ами, възможността да напишем верижка от извиквания на този оператор:

    String a("References");
    String b(" are");
    String c(" cool");
    cout << a << b << c;        // Извежда се: References are cool

Операторът е двуместен, т.е. има лява и дясна страна. И тъй като сме го написали три пъти, той се изпълнява три пъти, като се започне с
най-левия оператор <<. Щеше да е същото, ако последният ред беше: ((cout << a) << b) << c; 
    
E, за да може да напишем  (cout << a) << b  и това да е същото, както

    cout << a;
    cout << b; 
    
трябва (cout << a) да e равно на cout. И понеже всяко четене или писане променя обекта-stream, трябва да се връща референция, а не копие.

## Защо операторите = връщат *this

За да можем да напишем:
    
    String x, y, z;
    x = y = z = "Easter";
    
Което е същото като

    x = (y = (z = "Easter"));

Резултатът - и трите стринга стават "Easter". Този път се изпълнява първо най-десният оператор.
Това е така, защото двуместните оператори в C++ са два вида:

- Ляво асоциативни - ако има верижка, първо се изпълнява най-левият оператор и се продължава нядясно. Такива са << и >>.
- Дясно асоциативни - ако има верижка, първо се изпълнява най-десният оператор и се продължава наляво. Такъв е =.

Въпреки че можем да накараме оператора, който дефинираме, да прави каквото му кажем, посоката на асоциативността не може да се промени -
винаги, когато дефинираме <<, той ще е ляво асоциативен и винаги, когато дефинираме =, той ще е дясно асоциативен.
Кой оператор какъв е, пише в [Уикипедия](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence).

## Малка забележка

Когато връщаме референция, трябва сме сигурни, че тя сочи към променлива, която ще съществува след изпълнението
на функцията - т.е. да сочи към едно от следните неща:

- променлива в динамична памет
- променлива, подадена като аргумент
- променлива, която е дефинирана извън функцията - например член-данна на класа или *this

Единственият случай, в който променлива не изпълнява горните условия, е когато променливата е дефинирана в стека вътре във функцията.
Тогава обаче няма никакъв смисъл да искаме да я променяме след завършването на функцията, така че това рядко е проблем. 