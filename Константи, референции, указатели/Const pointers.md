# Константи и указатели

Обикновените указатели не могат да сочат към константа.
Но С++ има и друг вид указател - т.нар. **указател към константа**.
Името е донякъде подвеждащо, защото указателят към константа може да сочи и променлива.
Дефинира се с написване на const отпред:

    int variable = 3;
    const int* pointer = &variable;

Не можем да сменим стойността на променлива през такъв указател, но все пак можем да я достъпим,
а и е възможно стойността все пак да бъде сменена по друг начин.

    *pointer = 4;       // Нелегално - не можем да променим стойността през указателя
    cout << *pointer;   // ОК - нищо не се променя
    variable = 4;       // ОК - променяме стойността, но не през указателя

Ако указателят към константа сочи обект от клас, можем да викаме само const методи.

## Указатели към константа във функции

Също както и const референцията, указателят към константа влиза в употреба при писането на функции.
Понякога няма как да декларираме аргумента като референция - например, когато функцията приема масив
или когато е възможно да подадем NULL.

"Правилата за употреба" са сходни с тези за const референцията - ако искаме да можем да променяме това, към което сочи указателя - 
използваме обикновен указател, а ако не искаме - указател към константа.

## Една функция може да връща указател

- Ако връща обикновен указател, можем да правим каквото си искаме с него
- Ако връща указател към константа, не можем да променим стойността, към която сочи указателя (а ако сочи към обект от клас -
само const методите!), при това не можем да насочим обикновен указател натам.

<br>

    class Programmer {
        char* name;
        // ...
        const char* get_name() {
            return name;
        }
    };
    int main() {
        Programmer gosho;
        gosho.set_name("Gosho");
        
        char* bad_pointer = gosho.get_name();         // Нелегално, но щеше да стане, ако
                                                      // get_name връщаше обикновен указател
        gosho.get_name()[0] = 'T';                    // Нелегално, но щеше да стане, ако
                                                      // get_name връщаше обикновен указател
        const char* good_pointer = gosho.get_name();  // ОК и в двата случая
    }

## Указател към константа != константен указател

В С++ има и още един по-специален указател - т.нар. **константен указател**. Това е указател, който не може да бъде пренасочен.
Понятията "костантен указател" и "указател към константа" не бива да се бъркат!

По подразбиране всички указатели, дефинирани като нединамични масиви или аргументи на функции са константни.

    void foo(int* argument) {
        argument = NULL;
    }
    int main() {
        int n = 9;
        int* pointer_to_n = &n;
        foo(pointer_to_n);               // Викаме функция, която уж пренасочва указателя - към NULL.
        
        cout << *pointer_to_n;           // Но на този ред се извежда 9.
                                         // pointer_to_n все още сочи n.                              
        int arr[5] = { 1, 2, 3, 4, 5 };
        arr = &n;                        // Този ред не се компилира.
    }
    
Рядко се налага да имаме константен указател в друга ситуация, но ако все пак искаме,
можем да дефинираме константен указател и експлицитно:

    int* const immovable_pointer = &n;
    immovable_pointer = arr;            // Този ред не се компилира.